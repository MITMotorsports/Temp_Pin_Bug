
bin/can-node.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__isr_vector>:
   0:	10002000 	.word	0x10002000
   4:	000000c1 	.word	0x000000c1
   8:	000000e1 	.word	0x000000e1
   c:	000000e3 	.word	0x000000e3
	...
  2c:	000000e5 	.word	0x000000e5
	...
  38:	000000e7 	.word	0x000000e7
  3c:	0000024d 	.word	0x0000024d
  40:	000000eb 	.word	0x000000eb
  44:	000000eb 	.word	0x000000eb
  48:	000000eb 	.word	0x000000eb
  4c:	000000eb 	.word	0x000000eb
  50:	000000eb 	.word	0x000000eb
  54:	000000eb 	.word	0x000000eb
  58:	000000eb 	.word	0x000000eb
  5c:	000000eb 	.word	0x000000eb
  60:	000000eb 	.word	0x000000eb
  64:	000000eb 	.word	0x000000eb
  68:	000000eb 	.word	0x000000eb
  6c:	000000eb 	.word	0x000000eb
  70:	000000eb 	.word	0x000000eb
  74:	00000239 	.word	0x00000239
  78:	000000eb 	.word	0x000000eb
  7c:	000000eb 	.word	0x000000eb
  80:	000000eb 	.word	0x000000eb
  84:	000000eb 	.word	0x000000eb
  88:	000000eb 	.word	0x000000eb
  8c:	000000eb 	.word	0x000000eb
  90:	000000eb 	.word	0x000000eb
  94:	000000eb 	.word	0x000000eb
	...
  a0:	000000eb 	.word	0x000000eb
  a4:	000000eb 	.word	0x000000eb
  a8:	000000eb 	.word	0x000000eb
  ac:	00000000 	.word	0x00000000
  b0:	000000eb 	.word	0x000000eb
  b4:	000000eb 	.word	0x000000eb
  b8:	000000eb 	.word	0x000000eb
  bc:	000000eb 	.word	0x000000eb

000000c0 <Reset_Handler>:
 *    __bss_start__: start of the BSS section.
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
    ldr r1, =__bss_start__
  c0:	4905      	ldr	r1, [pc, #20]	; (d8 <Reset_Handler+0x18>)
    ldr r2, =__bss_end__
  c2:	4a06      	ldr	r2, [pc, #24]	; (dc <Reset_Handler+0x1c>)

    movs    r0, #0
  c4:	2000      	movs	r0, #0

    sub    r2, r1
  c6:	1a52      	subs	r2, r2, r1
    ble .L_loop3_done
  c8:	dd02      	ble.n	d0 <Reset_Handler+0x10>

.L_loop3:
    sub    r2, #4
  ca:	3a04      	subs	r2, #4
    str r0, [r1, r2]
  cc:	5088      	str	r0, [r1, r2]
    bgt .L_loop3
  ce:	dcfc      	bgt.n	ca <Reset_Handler+0xa>
.L_loop3_done:
#endif /* __STARTUP_CLEAR_BSS */


#ifndef __NO_SYSTEM_INIT
    bl  SystemInit
  d0:	f000 f96e 	bl	3b0 <SystemInit>
#endif

#ifndef __START
#define __START _start
#endif
    bl  __START
  d4:	f000 f8c2 	bl	25c <main>
 *    __bss_start__: start of the BSS section.
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
    ldr r1, =__bss_start__
  d8:	10000100 	.word	0x10000100
    ldr r2, =__bss_end__
  dc:	1000010c 	.word	0x1000010c

000000e0 <NMI_Handler>:
/* Exception Handlers */

    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    B       .
  e0:	e7fe      	b.n	e0 <NMI_Handler>

000000e2 <HardFault_Handler>:
    .size   NMI_Handler, . - NMI_Handler

    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    B       .
  e2:	e7fe      	b.n	e2 <HardFault_Handler>

000000e4 <SVC_Handler>:
    .size   HardFault_Handler, . - HardFault_Handler

    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    B       .
  e4:	e7fe      	b.n	e4 <SVC_Handler>

000000e6 <PendSV_Handler>:
    .size   SVC_Handler, . - SVC_Handler

    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    B       .
  e6:	e7fe      	b.n	e6 <PendSV_Handler>
    .size   PendSV_Handler, . - PendSV_Handler

    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    B       .
  e8:	e7fe      	b.n	e8 <PendSV_Handler+0x2>

000000ea <Default_Handler>:
/* IRQ Handlers */

    .globl  Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    B       .
  ea:	e7fe      	b.n	ea <Default_Handler>

000000ec <SystemCoreClockUpdate>:
 ****************************************************************************/

/* Update system core clock rate, should be called if the system has
   a clock rate change */
void SystemCoreClockUpdate(void)
{
  ec:	b508      	push	{r3, lr}
	/* CPU core speed */
	SystemCoreClock = Chip_Clock_GetSystemClockRate();
  ee:	f000 f853 	bl	198 <Chip_Clock_GetSystemClockRate>
  f2:	4b01      	ldr	r3, [pc, #4]	; (f8 <SystemCoreClockUpdate+0xc>)
  f4:	6018      	str	r0, [r3, #0]
}
  f6:	bd08      	pop	{r3, pc}
  f8:	10000100 	.word	0x10000100

000000fc <Chip_Clock_GetSystemPLLOutClockRate>:
}

/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
	return Chip_Clock_GetPLLFreq(LPC_SYSCTL->SYSPLLCTRL,
  fc:	4b0c      	ldr	r3, [pc, #48]	; (130 <Chip_Clock_GetSystemPLLOutClockRate+0x34>)
	return clkRate;
}

/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
  fe:	b082      	sub	sp, #8
	return Chip_Clock_GetPLLFreq(LPC_SYSCTL->SYSPLLCTRL,
 100:	689a      	ldr	r2, [r3, #8]
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 102:	6c19      	ldr	r1, [r3, #64]	; 0x40
 104:	2303      	movs	r3, #3
 106:	400b      	ands	r3, r1
 108:	d00c      	beq.n	124 <Chip_Clock_GetSystemPLLOutClockRate+0x28>
 10a:	2b01      	cmp	r3, #1
 10c:	d002      	beq.n	114 <Chip_Clock_GetSystemPLLOutClockRate+0x18>
 10e:	2000      	movs	r0, #0
/* Return System PLL output clock rate */
uint32_t Chip_Clock_GetSystemPLLOutClockRate(void)
{
	return Chip_Clock_GetPLLFreq(LPC_SYSCTL->SYSPLLCTRL,
								 Chip_Clock_GetSystemPLLInClockRate());
}
 110:	b002      	add	sp, #8
 112:	4770      	bx	lr
 114:	201f      	movs	r0, #31
 * @brief	Returns the main oscillator clock rate
 * @return	main oscillator clock rate
 */
STATIC INLINE uint32_t Chip_Clock_GetMainOscRate(void)
{
	return OscRateIn;
 116:	4b07      	ldr	r3, [pc, #28]	; (134 <Chip_Clock_GetSystemPLLOutClockRate+0x38>)
 118:	4010      	ands	r0, r2
 11a:	681b      	ldr	r3, [r3, #0]
 11c:	3001      	adds	r0, #1
 11e:	9301      	str	r3, [sp, #4]
 120:	4358      	muls	r0, r3
 122:	e7f5      	b.n	110 <Chip_Clock_GetSystemPLLOutClockRate+0x14>
 124:	201f      	movs	r0, #31
 126:	4002      	ands	r2, r0
 128:	4803      	ldr	r0, [pc, #12]	; (138 <Chip_Clock_GetSystemPLLOutClockRate+0x3c>)
 12a:	3201      	adds	r2, #1
 12c:	4350      	muls	r0, r2
 12e:	e7ef      	b.n	110 <Chip_Clock_GetSystemPLLOutClockRate+0x14>
 130:	40048000 	.word	0x40048000
 134:	000005f8 	.word	0x000005f8
 138:	00b71b00 	.word	0x00b71b00

0000013c <Chip_Clock_GetMainClockRate>:
/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
 13c:	2203      	movs	r2, #3
 13e:	4912      	ldr	r1, [pc, #72]	; (188 <Chip_Clock_GetMainClockRate+0x4c>)

#endif

/* Return main clock rate */
uint32_t Chip_Clock_GetMainClockRate(void)
{
 140:	b508      	push	{r3, lr}
	uint32_t clkRate = 0;

	switch ((CHIP_SYSCTL_MAINCLKSRC_T) (LPC_SYSCTL->MAINCLKSEL & 0x3)) {
 142:	6f0b      	ldr	r3, [r1, #112]	; 0x70
 144:	4013      	ands	r3, r2
 146:	2b02      	cmp	r3, #2
 148:	d011      	beq.n	16e <Chip_Clock_GetMainClockRate+0x32>
 14a:	2b03      	cmp	r3, #3
 14c:	d00c      	beq.n	168 <Chip_Clock_GetMainClockRate+0x2c>
 14e:	2b01      	cmp	r3, #1
 150:	d001      	beq.n	156 <Chip_Clock_GetMainClockRate+0x1a>
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
	case SYSCTL_PLLCLKSRC_IRC:
		clkRate = Chip_Clock_GetIntOscRate();
 152:	480e      	ldr	r0, [pc, #56]	; (18c <Chip_Clock_GetMainClockRate+0x50>)
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
		break;
	}

	return clkRate;
}
 154:	bd08      	pop	{r3, pc}
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 156:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 158:	401a      	ands	r2, r3
 15a:	d0fa      	beq.n	152 <Chip_Clock_GetMainClockRate+0x16>
		clkRate = Chip_Clock_GetExtClockInRate();
		break;
#endif

	default:
		clkRate = 0;
 15c:	2000      	movs	r0, #0
/* Return System PLL input clock rate */
uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
{
	uint32_t clkRate;

	switch ((CHIP_SYSCTL_PLLCLKSRC_T) (LPC_SYSCTL->SYSPLLCLKSEL & 0x3)) {
 15e:	2a01      	cmp	r2, #1
 160:	d1f8      	bne.n	154 <Chip_Clock_GetMainClockRate+0x18>
 162:	4b0b      	ldr	r3, [pc, #44]	; (190 <Chip_Clock_GetMainClockRate+0x54>)
 164:	6818      	ldr	r0, [r3, #0]
 166:	e7f5      	b.n	154 <Chip_Clock_GetMainClockRate+0x18>
		clkRate = Chip_Clock_GetWDTOSCRate();
		break;
#endif

	case SYSCTL_MAINCLKSRC_PLLOUT:
		clkRate = Chip_Clock_GetSystemPLLOutClockRate();
 168:	f7ff ffc8 	bl	fc <Chip_Clock_GetSystemPLLOutClockRate>
		break;
 16c:	e7f2      	b.n	154 <Chip_Clock_GetMainClockRate+0x18>
#endif

/* Return estimated watchdog oscillator rate */
uint32_t Chip_Clock_GetWDTOSCRate(void)
{
	return Chip_Clock_GetWDTLFORate(LPC_SYSCTL->WDTOSCCTRL);
 16e:	6a4b      	ldr	r3, [r1, #36]	; 0x24
	uint32_t div;
	CHIP_WDTLFO_OSC_T clk;

	/* Get WDT oscillator settings */
	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
	div = reg & 0x1F;
 170:	211f      	movs	r1, #31
{
	uint32_t div;
	CHIP_WDTLFO_OSC_T clk;

	/* Get WDT oscillator settings */
	clk = (CHIP_WDTLFO_OSC_T) ((reg >> 5) & 0xF);
 172:	05da      	lsls	r2, r3, #23
	div = reg & 0x1F;
 174:	4019      	ands	r1, r3

	/* Compute clock rate and divided by divde value */
	return wdtOSCRate[clk] / ((div + 1) << 1);
 176:	0f12      	lsrs	r2, r2, #28
 178:	4b06      	ldr	r3, [pc, #24]	; (194 <Chip_Clock_GetMainClockRate+0x58>)
 17a:	0092      	lsls	r2, r2, #2
 17c:	3101      	adds	r1, #1
 17e:	0049      	lsls	r1, r1, #1
 180:	58d0      	ldr	r0, [r2, r3]
 182:	f000 f953 	bl	42c <__aeabi_uidiv>
		break;

#else
	case SYSCTL_MAINCLKSRC_WDTOSC:
		clkRate = Chip_Clock_GetWDTOSCRate();
		break;
 186:	e7e5      	b.n	154 <Chip_Clock_GetMainClockRate+0x18>
 188:	40048000 	.word	0x40048000
 18c:	00b71b00 	.word	0x00b71b00
 190:	000005f8 	.word	0x000005f8
 194:	000005b8 	.word	0x000005b8

00000198 <Chip_Clock_GetSystemClockRate>:
	return clkRate;
}

/* Return system clock rate */
uint32_t Chip_Clock_GetSystemClockRate(void)
{
 198:	b508      	push	{r3, lr}
	/* No point in checking for divide by 0 */
	return Chip_Clock_GetMainClockRate() / LPC_SYSCTL->SYSAHBCLKDIV;
 19a:	f7ff ffcf 	bl	13c <Chip_Clock_GetMainClockRate>
 19e:	4b02      	ldr	r3, [pc, #8]	; (1a8 <Chip_Clock_GetSystemClockRate+0x10>)
 1a0:	6f99      	ldr	r1, [r3, #120]	; 0x78
 1a2:	f000 f943 	bl	42c <__aeabi_uidiv>
}
 1a6:	bd08      	pop	{r3, pc}
 1a8:	40048000 	.word	0x40048000

000001ac <Chip_UART_Init>:
 * @param	clk	: Clock to enable
 * @return	Nothing
 */
STATIC INLINE void Chip_Clock_EnablePeriphClock(CHIP_SYSCTL_CLOCK_T clk)
{
	LPC_SYSCTL->SYSAHBCLKCTRL |= (1 << clk);
 1ac:	2180      	movs	r1, #128	; 0x80
 * Public functions
 ****************************************************************************/

/* Initializes the pUART peripheral */
void Chip_UART_Init(LPC_USART_T *pUART)
{
 1ae:	b510      	push	{r4, lr}
 1b0:	2480      	movs	r4, #128	; 0x80
 1b2:	4b07      	ldr	r3, [pc, #28]	; (1d0 <Chip_UART_Init+0x24>)
 1b4:	0164      	lsls	r4, r4, #5
 1b6:	585a      	ldr	r2, [r3, r1]
 1b8:	4322      	orrs	r2, r4
 1ba:	505a      	str	r2, [r3, r1]
 * @note	Use 0 to disable, or a divider value of 1 to 255. The UART clock
 * rate is the main system clock divided by this value.
 */
STATIC INLINE void Chip_Clock_SetUARTClockDiv(uint32_t div)
{
	LPC_SYSCTL->USARTCLKDIV  = div;
 1bc:	2298      	movs	r2, #152	; 0x98
 1be:	397f      	subs	r1, #127	; 0x7f
 1c0:	5099      	str	r1, [r3, r2]
 *			with a RX trip level of 8 characters, use something like
 *			(UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2)
 */
STATIC INLINE void Chip_UART_SetupFIFOS(LPC_USART_T *pUART, uint32_t fcr)
{
	pUART->FCR = fcr;
 1c2:	2307      	movs	r3, #7
 1c4:	6083      	str	r3, [r0, #8]
 *			stop bit, and even (enabled) parity would be
 *			(UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
	pUART->LCR = config;
 1c6:	3b04      	subs	r3, #4
 1c8:	60c3      	str	r3, [r0, #12]

	/* Default 8N1, with DLAB disabled */
	Chip_UART_ConfigData(pUART, (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS));

	/* Disable fractional divider */
	pUART->FDR = 0x10;
 1ca:	330d      	adds	r3, #13
 1cc:	6283      	str	r3, [r0, #40]	; 0x28
}
 1ce:	bd10      	pop	{r4, pc}
 1d0:	40048000 	.word	0x40048000

000001d4 <Chip_UART_SendBlocking>:
	return sent;
}

/* Transmit a byte array through the UART peripheral (blocking) */
int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes)
{
 1d4:	b570      	push	{r4, r5, r6, lr}
	int pass, sent = 0;
	uint8_t *p8 = (uint8_t *) data;

	while (numBytes > 0) {
 1d6:	2600      	movs	r6, #0
	int sent = 0;
	uint8_t *p8 = (uint8_t *) data;

	/* Send until the transmit FIFO is full or out of bytes */
	while ((sent < numBytes) &&
		   ((Chip_UART_ReadLineStatus(pUART) & UART_LSR_THRE) != 0)) {
 1d8:	2520      	movs	r5, #32
int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes)
{
	int pass, sent = 0;
	uint8_t *p8 = (uint8_t *) data;

	while (numBytes > 0) {
 1da:	2a00      	cmp	r2, #0
 1dc:	dd0d      	ble.n	1fa <Chip_UART_SendBlocking+0x26>
	return sent;
}

/* Transmit a byte array through the UART peripheral (blocking) */
int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes)
{
 1de:	2300      	movs	r3, #0
 * @note	Mask bits of the returned status value with UART_LSR_*
 *			definitions for specific statuses.
 */
STATIC INLINE uint32_t Chip_UART_ReadLineStatus(LPC_USART_T *pUART)
{
	return pUART->LSR;
 1e0:	6944      	ldr	r4, [r0, #20]
{
	int sent = 0;
	uint8_t *p8 = (uint8_t *) data;

	/* Send until the transmit FIFO is full or out of bytes */
	while ((sent < numBytes) &&
 1e2:	4225      	tst	r5, r4
 1e4:	d004      	beq.n	1f0 <Chip_UART_SendBlocking+0x1c>
 * @note	This function attempts to place a byte into the UART transmit
 *			FIFO or transmit hold register regard regardless of UART state
 */
STATIC INLINE void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
{
	pUART->THR = (uint32_t) data;
 1e6:	5ccc      	ldrb	r4, [r1, r3]
		   ((Chip_UART_ReadLineStatus(pUART) & UART_LSR_THRE) != 0)) {
		Chip_UART_SendByte(pUART, *p8);
		p8++;
		sent++;
 1e8:	3301      	adds	r3, #1
 1ea:	6004      	str	r4, [r0, #0]
{
	int sent = 0;
	uint8_t *p8 = (uint8_t *) data;

	/* Send until the transmit FIFO is full or out of bytes */
	while ((sent < numBytes) &&
 1ec:	429a      	cmp	r2, r3
 1ee:	dcf7      	bgt.n	1e0 <Chip_UART_SendBlocking+0xc>
	int pass, sent = 0;
	uint8_t *p8 = (uint8_t *) data;

	while (numBytes > 0) {
		pass = Chip_UART_Send(pUART, p8, numBytes);
		numBytes -= pass;
 1f0:	1ad2      	subs	r2, r2, r3
		sent += pass;
 1f2:	18f6      	adds	r6, r6, r3
		p8 += pass;
 1f4:	18c9      	adds	r1, r1, r3
int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes)
{
	int pass, sent = 0;
	uint8_t *p8 = (uint8_t *) data;

	while (numBytes > 0) {
 1f6:	2a00      	cmp	r2, #0
 1f8:	dcf1      	bgt.n	1de <Chip_UART_SendBlocking+0xa>
		sent += pass;
		p8 += pass;
	}

	return sent;
}
 1fa:	1c30      	adds	r0, r6, #0
 1fc:	bd70      	pop	{r4, r5, r6, pc}
 1fe:	46c0      	nop			; (mov r8, r8)

00000200 <Chip_UART_SetBaud>:
	return readBytes;
}

/* Determines and sets best dividers to get a target bit rate */
uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
{
 200:	b570      	push	{r4, r5, r6, lr}
 202:	1c0e      	adds	r6, r1, #0
 204:	1c04      	adds	r4, r0, #0
	uint32_t div, divh, divl, clkin;

	/* Determine UART clock in rate without FDR */
	clkin = Chip_Clock_GetMainClockRate();
 206:	f7ff ff99 	bl	13c <Chip_Clock_GetMainClockRate>
	div = clkin / (baudrate * 16);
 20a:	0131      	lsls	r1, r6, #4
uint32_t Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
{
	uint32_t div, divh, divl, clkin;

	/* Determine UART clock in rate without FDR */
	clkin = Chip_Clock_GetMainClockRate();
 20c:	1c05      	adds	r5, r0, #0
	div = clkin / (baudrate * 16);
 20e:	f000 f90d 	bl	42c <__aeabi_uidiv>
 * @param	pUART	: Pointer to selected UART peripheral
 * @return	Nothing
 */
STATIC INLINE void Chip_UART_EnableDivisorAccess(LPC_USART_T *pUART)
{
	pUART->LCR |= UART_LCR_DLAB_EN;
 212:	2280      	movs	r2, #128	; 0x80
 214:	1c01      	adds	r1, r0, #0
 216:	68e3      	ldr	r3, [r4, #12]
 *			order to access the USART Divisor Latches. This function
 *			doesn't alter the DLAB state.
 */
STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
{
	pUART->DLL = (uint32_t) dll;
 218:	1c0e      	adds	r6, r1, #0
 * @param	pUART	: Pointer to selected UART peripheral
 * @return	Nothing
 */
STATIC INLINE void Chip_UART_EnableDivisorAccess(LPC_USART_T *pUART)
{
	pUART->LCR |= UART_LCR_DLAB_EN;
 21a:	4313      	orrs	r3, r2
 21c:	60e3      	str	r3, [r4, #12]

	/* High and low halves of the divider */
	divh = div / 256;
	divl = div - (divh * 256);
 21e:	0a03      	lsrs	r3, r0, #8
 *			order to access the USART Divisor Latches. This function
 *			doesn't alter the DLAB state.
 */
STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
{
	pUART->DLL = (uint32_t) dll;
 220:	20ff      	movs	r0, #255	; 0xff
 222:	4006      	ands	r6, r0
	pUART->DLM = (uint32_t) dlm;
 224:	4003      	ands	r3, r0
 *			order to access the USART Divisor Latches. This function
 *			doesn't alter the DLAB state.
 */
STATIC INLINE void Chip_UART_SetDivisorLatches(LPC_USART_T *pUART, uint8_t dll, uint8_t dlm)
{
	pUART->DLL = (uint32_t) dll;
 226:	6026      	str	r6, [r4, #0]
	pUART->DLM = (uint32_t) dlm;
 228:	6063      	str	r3, [r4, #4]
 * @param	pUART	: Pointer to selected UART peripheral
 * @return	Nothing
 */
STATIC INLINE void Chip_UART_DisableDivisorAccess(LPC_USART_T *pUART)
{
	pUART->LCR &= ~UART_LCR_DLAB_EN;
 22a:	68e3      	ldr	r3, [r4, #12]
	Chip_UART_SetDivisorLatches(pUART, divl, divh);
	Chip_UART_DisableDivisorAccess(pUART);

	/* Fractional FDR alreadt setup for 1 in UART init */

	return clkin / div;
 22c:	1c28      	adds	r0, r5, #0
 22e:	4393      	bics	r3, r2
 230:	60e3      	str	r3, [r4, #12]
 232:	f000 f8fb 	bl	42c <__aeabi_uidiv>
}
 236:	bd70      	pop	{r4, r5, r6, pc}

00000238 <CAN_IRQHandler>:
 * @brief	CCAN Interrupt Handler
 * @return	Nothing
 * @note	The CCAN interrupt handler must be provided by the user application.
 *	It's function is to call the isr() API located in the ROM
 */
void CAN_IRQHandler(void) {
 238:	b508      	push	{r3, lr}
	LPC_CCAN_API->isr();
 23a:	4b03      	ldr	r3, [pc, #12]	; (248 <CAN_IRQHandler+0x10>)
 23c:	681b      	ldr	r3, [r3, #0]
 23e:	689b      	ldr	r3, [r3, #8]
 240:	685b      	ldr	r3, [r3, #4]
 242:	4798      	blx	r3
}
 244:	bd08      	pop	{r3, pc}
 246:	46c0      	nop			; (mov r8, r8)
 248:	1fff1ff8 	.word	0x1fff1ff8

0000024c <SysTick_Handler>:

/*****************************************************************************/

 /* Private function */
void SysTick_Handler(void) {
  msTicks++;
 24c:	4a02      	ldr	r2, [pc, #8]	; (258 <SysTick_Handler+0xc>)
 24e:	6813      	ldr	r3, [r2, #0]
 250:	3301      	adds	r3, #1
 252:	6013      	str	r3, [r2, #0]
}
 254:	4770      	bx	lr
 256:	46c0      	nop			; (mov r8, r8)
 258:	10000104 	.word	0x10000104

0000025c <main>:

/****************************************************************************/

int main(void) {
 25c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 25e:	465f      	mov	r7, fp
 260:	4656      	mov	r6, sl
 262:	464d      	mov	r5, r9
 264:	4644      	mov	r4, r8
 266:	b4f0      	push	{r4, r5, r6, r7}

  SystemCoreClockUpdate();
 268:	f7ff ff40 	bl	ec <SystemCoreClockUpdate>

  if (SysTick_Config (SystemCoreClock / 1000)) {
 26c:	21fa      	movs	r1, #250	; 0xfa
 26e:	4b29      	ldr	r3, [pc, #164]	; (314 <main+0xb8>)
 270:	0089      	lsls	r1, r1, #2
 272:	6818      	ldr	r0, [r3, #0]
 274:	f000 f8da 	bl	42c <__aeabi_uidiv>
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
 278:	4a27      	ldr	r2, [pc, #156]	; (318 <main+0xbc>)
 27a:	3801      	subs	r0, #1
 27c:	6050      	str	r0, [r2, #4]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
 27e:	20c0      	movs	r0, #192	; 0xc0
 280:	4926      	ldr	r1, [pc, #152]	; (31c <main+0xc0>)
 282:	0600      	lsls	r0, r0, #24
 284:	6a0b      	ldr	r3, [r1, #32]
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 286:	2400      	movs	r4, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
 288:	021b      	lsls	r3, r3, #8
 28a:	0a1b      	lsrs	r3, r3, #8
 28c:	4303      	orrs	r3, r0
 28e:	620b      	str	r3, [r1, #32]
    //Error
    while(1);
  }

  Serial_Init(SERIAL_BAUDRATE);
 290:	20e1      	movs	r0, #225	; 0xe1
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 292:	2307      	movs	r3, #7
{
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 294:	6094      	str	r4, [r2, #8]
 296:	0240      	lsls	r0, r0, #9
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 298:	6013      	str	r3, [r2, #0]
 29a:	f000 f855 	bl	348 <Serial_Init>
 * @param	modefunc	: OR'ed values or type IOCON_*
 * @return	Nothing
 */
STATIC INLINE void Chip_IOCON_PinMuxSet(LPC_IOCON_T *pIOCON, CHIP_IOCON_PIO_T pin, uint32_t modefunc)
{
	pIOCON->REG[pin] = modefunc;
 29e:	20a0      	movs	r0, #160	; 0xa0
 * @param	pin		: GPIO pin to set direction on as input
 * @return	Nothing
 */
STATIC INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
	pGPIO[port].DIR &= ~(1UL << pin);
 2a0:	2280      	movs	r2, #128	; 0x80
 2a2:	2520      	movs	r5, #32
 2a4:	4b1e      	ldr	r3, [pc, #120]	; (320 <main+0xc4>)
 2a6:	4e1f      	ldr	r6, [pc, #124]	; (324 <main+0xc8>)
 2a8:	501c      	str	r4, [r3, r0]
 2aa:	0212      	lsls	r2, r2, #8
 2ac:	58b1      	ldr	r1, [r6, r2]
 * @return	true if the GPIO is high, false if low
 * @note	This function replaces Chip_GPIO_ReadPortBit()
 */
STATIC INLINE bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
	return (pGPIO[port].DATA[1 << pin]) != 0;
 2ae:	2780      	movs	r7, #128	; 0x80
 * @param	pin		: GPIO pin to set direction on as input
 * @return	Nothing
 */
STATIC INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
	pGPIO[port].DIR &= ~(1UL << pin);
 2b0:	43a9      	bics	r1, r5
 2b2:	50b1      	str	r1, [r6, r2]
 2b4:	2101      	movs	r1, #1
 2b6:	501c      	str	r4, [r3, r0]
 2b8:	6799      	str	r1, [r3, #120]	; 0x78
 2ba:	58b0      	ldr	r0, [r6, r2]
 2bc:	4388      	bics	r0, r1
 2be:	50b0      	str	r0, [r6, r2]
 2c0:	6799      	str	r1, [r3, #120]	; 0x78
  // Wheel Speed 2
  Chip_IOCON_PinMuxSet(LPC_IOCON, IOCON_PIO1_0, IOCON_FUNC1 | IOCON_MODE_INACT);
  Chip_GPIO_SetPinDIRInput(LPC_GPIO, 1, 0);
  Chip_IOCON_PinMuxSet(LPC_IOCON, IOCON_PIO1_0, IOCON_FUNC1 | IOCON_MODE_INACT);

  Serial_Println("Started up");
 2c2:	4819      	ldr	r0, [pc, #100]	; (328 <main+0xcc>)
 2c4:	f000 f868 	bl	398 <Serial_Println>
 2c8:	4b18      	ldr	r3, [pc, #96]	; (32c <main+0xd0>)
 2ca:	4d19      	ldr	r5, [pc, #100]	; (330 <main+0xd4>)
 2cc:	469b      	mov	fp, r3
 2ce:	4b19      	ldr	r3, [pc, #100]	; (334 <main+0xd8>)
 2d0:	469a      	mov	sl, r3
 2d2:	4b19      	ldr	r3, [pc, #100]	; (338 <main+0xdc>)
 2d4:	4699      	mov	r9, r3
 2d6:	4b19      	ldr	r3, [pc, #100]	; (33c <main+0xe0>)
 2d8:	4698      	mov	r8, r3
 2da:	23fa      	movs	r3, #250	; 0xfa
 2dc:	009b      	lsls	r3, r3, #2
 2de:	469c      	mov	ip, r3
 2e0:	4464      	add	r4, ip

  uint32_t timestamp = 0;

  while (1) {
    if (timestamp + 1000 < msTicks) {
 2e2:	682b      	ldr	r3, [r5, #0]
 2e4:	429c      	cmp	r4, r3
 2e6:	d2fc      	bcs.n	2e2 <main+0x86>
      timestamp = msTicks;
 2e8:	682c      	ldr	r4, [r5, #0]
 * @return	true if the GPIO is high, false if low
 * @note	This function replaces Chip_GPIO_ReadPortBit()
 */
STATIC INLINE bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
{
	return (pGPIO[port].DATA[1 << pin]) != 0;
 2ea:	6873      	ldr	r3, [r6, #4]
      bool wheel_2_state = Chip_GPIO_GetPinState(LPC_GPIO, 1, 0);
      Serial_Print(wheel_2_state ? "2_HIGH" : "2_LOW");
 2ec:	4658      	mov	r0, fp
 2ee:	2b00      	cmp	r3, #0
 2f0:	d100      	bne.n	2f4 <main+0x98>
 2f2:	4813      	ldr	r0, [pc, #76]	; (340 <main+0xe4>)
 2f4:	f000 f844 	bl	380 <Serial_Print>
      Serial_Print(", ");
 2f8:	4650      	mov	r0, sl
 2fa:	f000 f841 	bl	380 <Serial_Print>
 2fe:	59f3      	ldr	r3, [r6, r7]
      bool wheel_1_state = Chip_GPIO_GetPinState(LPC_GPIO, 1, 5);
      Serial_Print(wheel_1_state ? "1_HIGH" : "1_LOW");
 300:	4648      	mov	r0, r9
 302:	2b00      	cmp	r3, #0
 304:	d100      	bne.n	308 <main+0xac>
 306:	480f      	ldr	r0, [pc, #60]	; (344 <main+0xe8>)
 308:	f000 f83a 	bl	380 <Serial_Print>
      Serial_Print("\n");
 30c:	4640      	mov	r0, r8
 30e:	f000 f837 	bl	380 <Serial_Print>
 312:	e7e2      	b.n	2da <main+0x7e>
 314:	10000100 	.word	0x10000100
 318:	e000e010 	.word	0xe000e010
 31c:	e000ed00 	.word	0xe000ed00
 320:	40044000 	.word	0x40044000
 324:	50010000 	.word	0x50010000
 328:	0000061c 	.word	0x0000061c
 32c:	000005fc 	.word	0x000005fc
 330:	10000104 	.word	0x10000104
 334:	00000628 	.word	0x00000628
 338:	0000060c 	.word	0x0000060c
 33c:	0000062c 	.word	0x0000062c
 340:	00000604 	.word	0x00000604
 344:	00000614 	.word	0x00000614

00000348 <Serial_Init>:
 348:	2201      	movs	r2, #1
 34a:	21a4      	movs	r1, #164	; 0xa4
#include <string.h>
#include <stdint.h>

#include "chip.h"

void Serial_Init(uint32_t baudrate) {
 34c:	b538      	push	{r3, r4, r5, lr}
 34e:	1c05      	adds	r5, r0, #0
 350:	4b09      	ldr	r3, [pc, #36]	; (378 <Serial_Init+0x30>)
  Chip_IOCON_PinMuxSet(LPC_IOCON, IOCON_PIO1_6, (IOCON_FUNC1 | IOCON_MODE_INACT)); /* RXD */
  Chip_IOCON_PinMuxSet(LPC_IOCON, IOCON_PIO1_7, (IOCON_FUNC1 | IOCON_MODE_INACT)); /* TXD */

  Chip_UART_Init(LPC_USART);
 352:	4c0a      	ldr	r4, [pc, #40]	; (37c <Serial_Init+0x34>)
 354:	505a      	str	r2, [r3, r1]
 356:	3104      	adds	r1, #4
 358:	505a      	str	r2, [r3, r1]
 35a:	1c20      	adds	r0, r4, #0
 35c:	f7ff ff26 	bl	1ac <Chip_UART_Init>
  Chip_UART_SetBaud(LPC_USART, baudrate);
 360:	1c29      	adds	r1, r5, #0
 362:	1c20      	adds	r0, r4, #0
 364:	f7ff ff4c 	bl	200 <Chip_UART_SetBaud>
 *			stop bit, and even (enabled) parity would be
 *			(UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_EN | UART_LCR_PARITY_EVEN)
 */
STATIC INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
{
	pUART->LCR = config;
 368:	2303      	movs	r3, #3
 36a:	60e3      	str	r3, [r4, #12]
 *			with a RX trip level of 8 characters, use something like
 *			(UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2)
 */
STATIC INLINE void Chip_UART_SetupFIFOS(LPC_USART_T *pUART, uint32_t fcr)
{
	pUART->FCR = fcr;
 36c:	337e      	adds	r3, #126	; 0x7e
 36e:	60a3      	str	r3, [r4, #8]
 * @param	pUART	: Pointer to selected pUART peripheral
 * @return Nothing
 */
STATIC INLINE void Chip_UART_TXEnable(LPC_USART_T *pUART)
{
	pUART->TER1 = UART_TER1_TXEN;
 370:	3b01      	subs	r3, #1
 372:	6323      	str	r3, [r4, #48]	; 0x30
  // Configure data width, parity, and stop bits
  Chip_UART_ConfigData(LPC_USART, (UART_LCR_WLEN8 | UART_LCR_SBS_1BIT | UART_LCR_PARITY_DIS));
  Chip_UART_SetupFIFOS(LPC_USART, (UART_FCR_FIFO_EN | UART_FCR_TRG_LEV2));
  Chip_UART_TXEnable(LPC_USART);
}
 374:	bd38      	pop	{r3, r4, r5, pc}
 376:	46c0      	nop			; (mov r8, r8)
 378:	40044000 	.word	0x40044000
 37c:	40008000 	.word	0x40008000

00000380 <Serial_Print>:

uint32_t Serial_Print(const char *str) {
 380:	b510      	push	{r4, lr}
 382:	1c04      	adds	r4, r0, #0
  return Chip_UART_SendBlocking(LPC_USART, str, strlen(str));
 384:	f000 f8e4 	bl	550 <strlen>
 388:	1c21      	adds	r1, r4, #0
 38a:	1c02      	adds	r2, r0, #0
 38c:	4801      	ldr	r0, [pc, #4]	; (394 <Serial_Print+0x14>)
 38e:	f7ff ff21 	bl	1d4 <Chip_UART_SendBlocking>
}
 392:	bd10      	pop	{r4, pc}
 394:	40008000 	.word	0x40008000

00000398 <Serial_Println>:

void Serial_Print_Void(const char *str) {
  Chip_UART_SendBlocking(LPC_USART, str, strlen(str));
}
uint32_t Serial_Println(const char *str) {
 398:	b510      	push	{r4, lr}
  uint32_t count = Serial_Print(str);
 39a:	f7ff fff1 	bl	380 <Serial_Print>
 39e:	1c04      	adds	r4, r0, #0
  return count + Serial_Print("\r\n");
 3a0:	4802      	ldr	r0, [pc, #8]	; (3ac <Serial_Println+0x14>)
 3a2:	f7ff ffed 	bl	380 <Serial_Print>
 3a6:	1900      	adds	r0, r0, r4
}
 3a8:	bd10      	pop	{r4, pc}
 3aa:	46c0      	nop			; (mov r8, r8)
 3ac:	00000630 	.word	0x00000630

000003b0 <SystemInit>:
 * @brief  Setup the microcontroller system.
 *		 Initialize the System.
 */
void SystemInit (void) {
#if (CLOCK_SETUP)								 /* Clock Setup			  */
  SystemCoreClock = __SYSTEM_CLOCK;
 3b0:	4a18      	ldr	r2, [pc, #96]	; (414 <SystemInit+0x64>)
 3b2:	4b19      	ldr	r3, [pc, #100]	; (418 <SystemInit+0x68>)
#endif
  LPC_SYSCTL->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input		 */
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x1;				/* Update Clock Source	  */
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x0;				/* Toggle Update Register   */
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x1;
  while (!(LPC_SYSCTL->SYSPLLCLKUEN & 0x1));	  /* Wait Until Updated	   */
 3b4:	2001      	movs	r0, #1
 * @brief  Setup the microcontroller system.
 *		 Initialize the System.
 */
void SystemInit (void) {
#if (CLOCK_SETUP)								 /* Clock Setup			  */
  SystemCoreClock = __SYSTEM_CLOCK;
 3b6:	601a      	str	r2, [r3, #0]
  TicksPerMS = __SYSTEM_CLOCK/1000;
 3b8:	4a18      	ldr	r2, [pc, #96]	; (41c <SystemInit+0x6c>)
 3ba:	4b19      	ldr	r3, [pc, #100]	; (420 <SystemInit+0x70>)

  LPC_SYSCTL->PDRUNCFG	 &= ~(1 << 5);		  /* Power-up System Osc	  */
  LPC_SYSCTL->SYSOSCCTRL	= SYSOSCCTRL_Val;
  for (i = 0; i < 200; i++) __NOP();
#endif
  LPC_SYSCTL->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input		 */
 3bc:	4919      	ldr	r1, [pc, #100]	; (424 <SystemInit+0x74>)
 *		 Initialize the System.
 */
void SystemInit (void) {
#if (CLOCK_SETUP)								 /* Clock Setup			  */
  SystemCoreClock = __SYSTEM_CLOCK;
  TicksPerMS = __SYSTEM_CLOCK/1000;
 3be:	601a      	str	r2, [r3, #0]

  LPC_SYSCTL->PDRUNCFG	 &= ~(1 << 5);		  /* Power-up System Osc	  */
  LPC_SYSCTL->SYSOSCCTRL	= SYSOSCCTRL_Val;
  for (i = 0; i < 200; i++) __NOP();
#endif
  LPC_SYSCTL->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input		 */
 3c0:	2200      	movs	r2, #0
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x1;				/* Update Clock Source	  */
 3c2:	2301      	movs	r3, #1

  LPC_SYSCTL->PDRUNCFG	 &= ~(1 << 5);		  /* Power-up System Osc	  */
  LPC_SYSCTL->SYSOSCCTRL	= SYSOSCCTRL_Val;
  for (i = 0; i < 200; i++) __NOP();
#endif
  LPC_SYSCTL->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input		 */
 3c4:	640a      	str	r2, [r1, #64]	; 0x40
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x1;				/* Update Clock Source	  */
 3c6:	644b      	str	r3, [r1, #68]	; 0x44
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x0;				/* Toggle Update Register   */
 3c8:	644a      	str	r2, [r1, #68]	; 0x44
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x1;
 3ca:	644b      	str	r3, [r1, #68]	; 0x44
  while (!(LPC_SYSCTL->SYSPLLCLKUEN & 0x1));	  /* Wait Until Updated	   */
 3cc:	6c4a      	ldr	r2, [r1, #68]	; 0x44
 3ce:	4b15      	ldr	r3, [pc, #84]	; (424 <SystemInit+0x74>)
 3d0:	4210      	tst	r0, r2
 3d2:	d0fb      	beq.n	3cc <SystemInit+0x1c>
#if (SYSPLL_SETUP)								/* System PLL Setup		 */
  LPC_SYSCTL->SYSPLLCTRL	= SYSPLLCTRL_Val;
 3d4:	2223      	movs	r2, #35	; 0x23
  LPC_SYSCTL->PDRUNCFG	 &= ~(1 << 7);		  /* Power-up SYSPLL		  */
 3d6:	218e      	movs	r1, #142	; 0x8e
 3d8:	2080      	movs	r0, #128	; 0x80
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x1;				/* Update Clock Source	  */
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x0;				/* Toggle Update Register   */
  LPC_SYSCTL->SYSPLLCLKUEN  = 0x1;
  while (!(LPC_SYSCTL->SYSPLLCLKUEN & 0x1));	  /* Wait Until Updated	   */
#if (SYSPLL_SETUP)								/* System PLL Setup		 */
  LPC_SYSCTL->SYSPLLCTRL	= SYSPLLCTRL_Val;
 3da:	609a      	str	r2, [r3, #8]
  LPC_SYSCTL->PDRUNCFG	 &= ~(1 << 7);		  /* Power-up SYSPLL		  */
 3dc:	0089      	lsls	r1, r1, #2
 3de:	585a      	ldr	r2, [r3, r1]
 3e0:	4382      	bics	r2, r0
 3e2:	505a      	str	r2, [r3, r1]
  while (!(LPC_SYSCTL->SYSPLLSTAT & 0x1));		/* Wait Until PLL Locked	*/
 3e4:	1c1a      	adds	r2, r3, #0
 3e6:	387f      	subs	r0, #127	; 0x7f
 3e8:	68d1      	ldr	r1, [r2, #12]
 3ea:	4b0e      	ldr	r3, [pc, #56]	; (424 <SystemInit+0x74>)
 3ec:	4208      	tst	r0, r1
 3ee:	d0fb      	beq.n	3e8 <SystemInit+0x38>
#endif
#if (WDTOSC_SETUP)								/* Watchdog Oscillator Setup*/
  LPC_SYSCTL->WDTOSCCTRL	= WDTOSCCTRL_Val;
  LPC_SYSCTL->PDRUNCFG	 &= ~(1 << 6);		  /* Power-up WDT Clock	   */
#endif
  LPC_SYSCTL->MAINCLKSEL	= MAINCLKSEL_Val;	 /* Select PLL Clock Output  */
 3f0:	2203      	movs	r2, #3
 3f2:	671a      	str	r2, [r3, #112]	; 0x70
  LPC_SYSCTL->MAINCLKUEN	= 0x0;				/* Toggle Update Register   */
 3f4:	2200      	movs	r2, #0
  LPC_SYSCTL->MAINCLKUEN	= 0x1;
  while (!(LPC_SYSCTL->MAINCLKUEN & 0x1));		/* Wait Until Updated	   */
 3f6:	2001      	movs	r0, #1
#if (WDTOSC_SETUP)								/* Watchdog Oscillator Setup*/
  LPC_SYSCTL->WDTOSCCTRL	= WDTOSCCTRL_Val;
  LPC_SYSCTL->PDRUNCFG	 &= ~(1 << 6);		  /* Power-up WDT Clock	   */
#endif
  LPC_SYSCTL->MAINCLKSEL	= MAINCLKSEL_Val;	 /* Select PLL Clock Output  */
  LPC_SYSCTL->MAINCLKUEN	= 0x0;				/* Toggle Update Register   */
 3f8:	675a      	str	r2, [r3, #116]	; 0x74
  LPC_SYSCTL->MAINCLKUEN	= 0x1;
 3fa:	3201      	adds	r2, #1
 3fc:	675a      	str	r2, [r3, #116]	; 0x74
  while (!(LPC_SYSCTL->MAINCLKUEN & 0x1));		/* Wait Until Updated	   */
 3fe:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 400:	4908      	ldr	r1, [pc, #32]	; (424 <SystemInit+0x74>)
 402:	4210      	tst	r0, r2
 404:	d0fb      	beq.n	3fe <SystemInit+0x4e>
#endif

  LPC_SYSCTL->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;
 406:	2301      	movs	r3, #1
  LPC_SYSCTL->SYSAHBCLKCTRL = AHBCLKCTRL_Val;
 408:	4a07      	ldr	r2, [pc, #28]	; (428 <SystemInit+0x78>)
  LPC_SYSCTL->MAINCLKUEN	= 0x0;				/* Toggle Update Register   */
  LPC_SYSCTL->MAINCLKUEN	= 0x1;
  while (!(LPC_SYSCTL->MAINCLKUEN & 0x1));		/* Wait Until Updated	   */
#endif

  LPC_SYSCTL->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;
 40a:	678b      	str	r3, [r1, #120]	; 0x78
  LPC_SYSCTL->SYSAHBCLKCTRL = AHBCLKCTRL_Val;
 40c:	337f      	adds	r3, #127	; 0x7f
 40e:	50ca      	str	r2, [r1, r3]
#endif

#if (MEMMAP_SETUP || MEMMAP_INIT)				  /* Memory Mapping Setup			   */
  LPC_SYSCTL->SYSMEMREMAP = SYSMEMREMAP_Val;
#endif
}
 410:	4770      	bx	lr
 412:	46c0      	nop			; (mov r8, r8)
 414:	02dc6c00 	.word	0x02dc6c00
 418:	10000100 	.word	0x10000100
 41c:	0000bb80 	.word	0x0000bb80
 420:	10000108 	.word	0x10000108
 424:	40048000 	.word	0x40048000
 428:	0001005f 	.word	0x0001005f

0000042c <__aeabi_uidiv>:
 42c:	2200      	movs	r2, #0
 42e:	0843      	lsrs	r3, r0, #1
 430:	428b      	cmp	r3, r1
 432:	d374      	bcc.n	51e <__aeabi_uidiv+0xf2>
 434:	0903      	lsrs	r3, r0, #4
 436:	428b      	cmp	r3, r1
 438:	d35f      	bcc.n	4fa <__aeabi_uidiv+0xce>
 43a:	0a03      	lsrs	r3, r0, #8
 43c:	428b      	cmp	r3, r1
 43e:	d344      	bcc.n	4ca <__aeabi_uidiv+0x9e>
 440:	0b03      	lsrs	r3, r0, #12
 442:	428b      	cmp	r3, r1
 444:	d328      	bcc.n	498 <__aeabi_uidiv+0x6c>
 446:	0c03      	lsrs	r3, r0, #16
 448:	428b      	cmp	r3, r1
 44a:	d30d      	bcc.n	468 <__aeabi_uidiv+0x3c>
 44c:	22ff      	movs	r2, #255	; 0xff
 44e:	0209      	lsls	r1, r1, #8
 450:	ba12      	rev	r2, r2
 452:	0c03      	lsrs	r3, r0, #16
 454:	428b      	cmp	r3, r1
 456:	d302      	bcc.n	45e <__aeabi_uidiv+0x32>
 458:	1212      	asrs	r2, r2, #8
 45a:	0209      	lsls	r1, r1, #8
 45c:	d065      	beq.n	52a <__aeabi_uidiv+0xfe>
 45e:	0b03      	lsrs	r3, r0, #12
 460:	428b      	cmp	r3, r1
 462:	d319      	bcc.n	498 <__aeabi_uidiv+0x6c>
 464:	e000      	b.n	468 <__aeabi_uidiv+0x3c>
 466:	0a09      	lsrs	r1, r1, #8
 468:	0bc3      	lsrs	r3, r0, #15
 46a:	428b      	cmp	r3, r1
 46c:	d301      	bcc.n	472 <__aeabi_uidiv+0x46>
 46e:	03cb      	lsls	r3, r1, #15
 470:	1ac0      	subs	r0, r0, r3
 472:	4152      	adcs	r2, r2
 474:	0b83      	lsrs	r3, r0, #14
 476:	428b      	cmp	r3, r1
 478:	d301      	bcc.n	47e <__aeabi_uidiv+0x52>
 47a:	038b      	lsls	r3, r1, #14
 47c:	1ac0      	subs	r0, r0, r3
 47e:	4152      	adcs	r2, r2
 480:	0b43      	lsrs	r3, r0, #13
 482:	428b      	cmp	r3, r1
 484:	d301      	bcc.n	48a <__aeabi_uidiv+0x5e>
 486:	034b      	lsls	r3, r1, #13
 488:	1ac0      	subs	r0, r0, r3
 48a:	4152      	adcs	r2, r2
 48c:	0b03      	lsrs	r3, r0, #12
 48e:	428b      	cmp	r3, r1
 490:	d301      	bcc.n	496 <__aeabi_uidiv+0x6a>
 492:	030b      	lsls	r3, r1, #12
 494:	1ac0      	subs	r0, r0, r3
 496:	4152      	adcs	r2, r2
 498:	0ac3      	lsrs	r3, r0, #11
 49a:	428b      	cmp	r3, r1
 49c:	d301      	bcc.n	4a2 <__aeabi_uidiv+0x76>
 49e:	02cb      	lsls	r3, r1, #11
 4a0:	1ac0      	subs	r0, r0, r3
 4a2:	4152      	adcs	r2, r2
 4a4:	0a83      	lsrs	r3, r0, #10
 4a6:	428b      	cmp	r3, r1
 4a8:	d301      	bcc.n	4ae <__aeabi_uidiv+0x82>
 4aa:	028b      	lsls	r3, r1, #10
 4ac:	1ac0      	subs	r0, r0, r3
 4ae:	4152      	adcs	r2, r2
 4b0:	0a43      	lsrs	r3, r0, #9
 4b2:	428b      	cmp	r3, r1
 4b4:	d301      	bcc.n	4ba <__aeabi_uidiv+0x8e>
 4b6:	024b      	lsls	r3, r1, #9
 4b8:	1ac0      	subs	r0, r0, r3
 4ba:	4152      	adcs	r2, r2
 4bc:	0a03      	lsrs	r3, r0, #8
 4be:	428b      	cmp	r3, r1
 4c0:	d301      	bcc.n	4c6 <__aeabi_uidiv+0x9a>
 4c2:	020b      	lsls	r3, r1, #8
 4c4:	1ac0      	subs	r0, r0, r3
 4c6:	4152      	adcs	r2, r2
 4c8:	d2cd      	bcs.n	466 <__aeabi_uidiv+0x3a>
 4ca:	09c3      	lsrs	r3, r0, #7
 4cc:	428b      	cmp	r3, r1
 4ce:	d301      	bcc.n	4d4 <__aeabi_uidiv+0xa8>
 4d0:	01cb      	lsls	r3, r1, #7
 4d2:	1ac0      	subs	r0, r0, r3
 4d4:	4152      	adcs	r2, r2
 4d6:	0983      	lsrs	r3, r0, #6
 4d8:	428b      	cmp	r3, r1
 4da:	d301      	bcc.n	4e0 <__aeabi_uidiv+0xb4>
 4dc:	018b      	lsls	r3, r1, #6
 4de:	1ac0      	subs	r0, r0, r3
 4e0:	4152      	adcs	r2, r2
 4e2:	0943      	lsrs	r3, r0, #5
 4e4:	428b      	cmp	r3, r1
 4e6:	d301      	bcc.n	4ec <__aeabi_uidiv+0xc0>
 4e8:	014b      	lsls	r3, r1, #5
 4ea:	1ac0      	subs	r0, r0, r3
 4ec:	4152      	adcs	r2, r2
 4ee:	0903      	lsrs	r3, r0, #4
 4f0:	428b      	cmp	r3, r1
 4f2:	d301      	bcc.n	4f8 <__aeabi_uidiv+0xcc>
 4f4:	010b      	lsls	r3, r1, #4
 4f6:	1ac0      	subs	r0, r0, r3
 4f8:	4152      	adcs	r2, r2
 4fa:	08c3      	lsrs	r3, r0, #3
 4fc:	428b      	cmp	r3, r1
 4fe:	d301      	bcc.n	504 <__aeabi_uidiv+0xd8>
 500:	00cb      	lsls	r3, r1, #3
 502:	1ac0      	subs	r0, r0, r3
 504:	4152      	adcs	r2, r2
 506:	0883      	lsrs	r3, r0, #2
 508:	428b      	cmp	r3, r1
 50a:	d301      	bcc.n	510 <__aeabi_uidiv+0xe4>
 50c:	008b      	lsls	r3, r1, #2
 50e:	1ac0      	subs	r0, r0, r3
 510:	4152      	adcs	r2, r2
 512:	0843      	lsrs	r3, r0, #1
 514:	428b      	cmp	r3, r1
 516:	d301      	bcc.n	51c <__aeabi_uidiv+0xf0>
 518:	004b      	lsls	r3, r1, #1
 51a:	1ac0      	subs	r0, r0, r3
 51c:	4152      	adcs	r2, r2
 51e:	1a41      	subs	r1, r0, r1
 520:	d200      	bcs.n	524 <__aeabi_uidiv+0xf8>
 522:	4601      	mov	r1, r0
 524:	4152      	adcs	r2, r2
 526:	4610      	mov	r0, r2
 528:	4770      	bx	lr
 52a:	e7ff      	b.n	52c <__aeabi_uidiv+0x100>
 52c:	b501      	push	{r0, lr}
 52e:	2000      	movs	r0, #0
 530:	f000 f80c 	bl	54c <__aeabi_idiv0>
 534:	bd02      	pop	{r1, pc}
 536:	46c0      	nop			; (mov r8, r8)

00000538 <__aeabi_uidivmod>:
 538:	2900      	cmp	r1, #0
 53a:	d0f7      	beq.n	52c <__aeabi_uidiv+0x100>
 53c:	b503      	push	{r0, r1, lr}
 53e:	f7ff ff75 	bl	42c <__aeabi_uidiv>
 542:	bc0e      	pop	{r1, r2, r3}
 544:	4342      	muls	r2, r0
 546:	1a89      	subs	r1, r1, r2
 548:	4718      	bx	r3
 54a:	46c0      	nop			; (mov r8, r8)

0000054c <__aeabi_idiv0>:
 54c:	4770      	bx	lr
 54e:	46c0      	nop			; (mov r8, r8)

00000550 <strlen>:
 550:	b510      	push	{r4, lr}
 552:	0783      	lsls	r3, r0, #30
 554:	d027      	beq.n	5a6 <strlen+0x56>
 556:	7803      	ldrb	r3, [r0, #0]
 558:	2b00      	cmp	r3, #0
 55a:	d026      	beq.n	5aa <strlen+0x5a>
 55c:	1c03      	adds	r3, r0, #0
 55e:	2103      	movs	r1, #3
 560:	e002      	b.n	568 <strlen+0x18>
 562:	781a      	ldrb	r2, [r3, #0]
 564:	2a00      	cmp	r2, #0
 566:	d01c      	beq.n	5a2 <strlen+0x52>
 568:	3301      	adds	r3, #1
 56a:	420b      	tst	r3, r1
 56c:	d1f9      	bne.n	562 <strlen+0x12>
 56e:	6819      	ldr	r1, [r3, #0]
 570:	4a0f      	ldr	r2, [pc, #60]	; (5b0 <strlen+0x60>)
 572:	4c10      	ldr	r4, [pc, #64]	; (5b4 <strlen+0x64>)
 574:	188a      	adds	r2, r1, r2
 576:	438a      	bics	r2, r1
 578:	4222      	tst	r2, r4
 57a:	d10f      	bne.n	59c <strlen+0x4c>
 57c:	3304      	adds	r3, #4
 57e:	6819      	ldr	r1, [r3, #0]
 580:	4a0b      	ldr	r2, [pc, #44]	; (5b0 <strlen+0x60>)
 582:	188a      	adds	r2, r1, r2
 584:	438a      	bics	r2, r1
 586:	4222      	tst	r2, r4
 588:	d108      	bne.n	59c <strlen+0x4c>
 58a:	3304      	adds	r3, #4
 58c:	6819      	ldr	r1, [r3, #0]
 58e:	4a08      	ldr	r2, [pc, #32]	; (5b0 <strlen+0x60>)
 590:	188a      	adds	r2, r1, r2
 592:	438a      	bics	r2, r1
 594:	4222      	tst	r2, r4
 596:	d0f1      	beq.n	57c <strlen+0x2c>
 598:	e000      	b.n	59c <strlen+0x4c>
 59a:	3301      	adds	r3, #1
 59c:	781a      	ldrb	r2, [r3, #0]
 59e:	2a00      	cmp	r2, #0
 5a0:	d1fb      	bne.n	59a <strlen+0x4a>
 5a2:	1a18      	subs	r0, r3, r0
 5a4:	bd10      	pop	{r4, pc}
 5a6:	1c03      	adds	r3, r0, #0
 5a8:	e7e1      	b.n	56e <strlen+0x1e>
 5aa:	2000      	movs	r0, #0
 5ac:	e7fa      	b.n	5a4 <strlen+0x54>
 5ae:	46c0      	nop			; (mov r8, r8)
 5b0:	fefefeff 	.word	0xfefefeff
 5b4:	80808080 	.word	0x80808080

000005b8 <wdtOSCRate>:
 5b8:	00000000 000927c0 00100590 00155cc0     .....'.......\..
 5c8:	001ab3f0 00200b20 00249f00 002932e0     .... . ...$..2).
 5d8:	002dc6c0 00319750 003567e0 00393870     ..-.P.1..g5.p89.
 5e8:	003d0900 00401640 00432380 004630c0     ..=.@.@..#C..0F.

000005f8 <OscRateIn>:
 5f8:	00b71b00 49485f32 00004847 4f4c5f32     ....2_HIGH..2_LO
 608:	00000057 49485f31 00004847 4f4c5f31     W...1_HIGH..1_LO
 618:	00000057 72617453 20646574 00007075     W...Started up..
 628:	0000202c 0000000a 00000a0d              , ..........
